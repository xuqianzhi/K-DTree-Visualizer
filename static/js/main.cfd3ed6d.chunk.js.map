{"version":3,"sources":["googlemaps.jpeg","logo.svg","Controller/Map.jsx","Model/KDTree.js","Controller/NeighborFindingVisualizer.jsx","Controller/Display.jsx","App.js","reportWebVitals.js","index.js"],"names":["ucblat","ucblng","getMarkerPixelCoordinate","marker","map","window","mapData","scale","Math","pow","getZoom","nw","google","maps","LatLng","getBounds","getNorthEast","lat","getSouthWest","lng","worldCoordinateNW","getProjection","fromLatLngToPoint","worldCoordinate","getPosition","x","floor","y","Map","props","visualizeKDTree","state","this","fetchGoogleMapsAPIScript","initMap","bind","script","document","createElement","setAttribute","async","src","process","type","onload","getElementById","appendChild","nearestInfowindow","InfoWindow","content","ucBerkeleyPos","center","zoom","mapTypeId","mapTypeControl","fullscreenControl","styles","visualizationButton","nearest_position","textContent","onclick","restartButtonClicked","controls","ControlPosition","TOP_RIGHT","push","ucb_icon","url","size","Size","origin","Point","anchor","scaledSize","ucb_marker","Marker","icon","title","position","input","searchBox","places","SearchBox","TOP_LEFT","addListener","setBounds","curr_markers","markers","length","bounds","LatLngBounds","extend","bestIndex","findNearestMarker","index","i","animation","Animation","BOUNCE","setMap","getTitle","fitBounds","button","getPlaces","forEach","place","geometry","location","name","viewport","union","alert","console","log","event","displayed_markers","slice","need_to_reset","pixel_pos","innerWidth","innerHeight","setZoom","setCenter","m","style","display","nearestPos","bestDist","Number","MAX_VALUE","markerPos","currDist","id","class","placeholder","Component","euclidean","dest_x","curr_x","dest_y","curr_y","sqrt","Dot","isVertical","Line","x_bound","y_bound","KDTree","dots","initial_x_bound","initial_y_bound","root_dot","root","TreeNode","sortCoordinates","constructTree","getRoot","result","iterate","getNodeTraversedAfterInsertion","stack","pop","curr_node","best_distance","nearest_neighbor","visited","Set","bound_animation","crossing_animation","add","getID","right","has","intersectDownOrRight","direction","left","intersectUpOrLeft","nearest","dot","setIsVertical","line","uuid","getDot","isSortingByX","sort","dot1","dot2","x1","x2","y1","y2","leftHalf","rightHalf","left_x_bound","left_y_bound","left_dot","min","max","right_x_bound","right_y_bound","right_dot","lst","getInsertedDestinationNode","inserted_x_bound","inserted_y_bound","inserted_dot","ANIMATION_LAG","LINE_DISPLAY_LAG","NeighborFindingVisualizer","tree_nodes","searching_bound","animation_speed","radar_radius","radar_direction","running_status","markerToPixelDots","kdtree","getKDTree","nodes","iterateTree","node","is_dot_displayed","is_line_displayed","drawing_line_length","setState","setTimeout","displaySearchingAnimation","pixelOffset","point","fromPointToLatLng","animation_begin_time","time_interval","from_bound","to_bound","num_intervals","x_bound_min","x_bound_max","y_bound_min","y_bound_max","to_x_bound","to_y_bound","x_bound_min_diff","x_bound_max_diff","y_bound_min_diff","y_bound_max_diff","j","local_xmin","local_xmax","local_ymin","local_ymax","displayed_length","dotID","prevDotID","prevDotColor","backgroundColor","start_x","start_y","thickness","color","border_radius","className","top","borderRadius","height","width","bottom","tree_node","time_elapsed","ucb_dot","getUCBDot","ucb_pos","insertion_animation","obj","performNearestSearching","nearest_id","bound","getXBound","getYBound","drawBoundAnimatedly","line_info","line_length","line_direction","line_animation_begin_time","drawLineAnimatedly","bound_animation_begin_time","nearest_dot","opacity","lines","getElementsByClassName","k","nearest_latlng","getLatLngFromPixelOffset","KDTreeToMap","searching_x_min","searching_x_max","searching_y_min","searching_y_max","is_radar_displayed","trigger","backgroundImage","backgroundSize","backgroundPosition","on","arrow","textAlign","marginTop","marginBottom","marginLeft","drawLine","bound_thickness","idx","getLine","node_id","getIsVertical","dot_opacity","line_display","line_color","dot_color","Display","viewToDisplay","stylers","setOptions","nearest_index","nearest_marker","setAnimation","open","shouldFocus","ViewToDisplay","popUpDisplay","shouldPopUpDisplay","defaultOpen","require","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.cfd3ed6d.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/googlemaps.f95ed196.jpeg\";","export default __webpack_public_path__ + \"static/media/logo.6ce24c58.svg\";","import React, { Component } from 'react';\nimport '../View/Map.css';\nimport Display, { visualizeKDTree } from './Display.jsx';\n\nconst ucblat = 37.871416963460454;\nconst ucblng = -122.26007750513202;\n\nfunction getMarkerPixelCoordinate(marker) {\n    /* \n    This function calculate pixel coordinate of the input marker, \n    # Parameter marker: google.Maps.markers\n    # Return: pixel coordinate {x, y} (AKA {left, top})\n    */\n    const map = window.mapData.map;\n    if (!map || !marker) { return; }\n    var scale = Math.pow(2, map.getZoom());\n    var nw = new window.google.maps.LatLng(\n        map.getBounds().getNorthEast().lat(),\n        map.getBounds().getSouthWest().lng()\n    );\n    var worldCoordinateNW = map.getProjection().fromLatLngToPoint(nw);\n    var worldCoordinate = map.getProjection().fromLatLngToPoint(marker.getPosition());\n    var pixelOffset = {\n        x: Math.floor((worldCoordinate.x - worldCoordinateNW.x) * scale),\n        y: Math.floor((worldCoordinate.y - worldCoordinateNW.y) * scale)\n    }\n    return pixelOffset;\n}\n\nexport default class Map extends Component {\n\n    constructor(props) {\n        super(props);\n        this.visualizeKDTree = this.props.visualizeKDTree;\n        this.state = {}\n    }\n\n    componentDidMount() {\n        this.fetchGoogleMapsAPIScript();\n    }\n\n    fetchGoogleMapsAPIScript() {\n        this.initMap = this.initMap.bind(this);\n        var script = document.createElement('script');\n        script.setAttribute('id', \"loadmap-script\");\n        script.async = true;\n        script.src = `https://maps.googleapis.com/maps/api/js?key=${process.env.REACT_APP_GOOGLE_MAPS_API_KEY}&libraries=places&v=weekly`;\n        script.type = \"text/javascript\";\n        script.onload = this.initMap;\n        document.getElementById('map-container').appendChild(script);\n    }\n\n    initMap() {\n        const google = window.google;\n        window.mapData.nearestInfowindow = new window.google.maps.InfoWindow({\n            content: 'Nearest Search Result',\n        });\n        var stylers = [{\n            \"stylers\": [{\n                \"lightness\": 0\n            }]\n        }];\n        const ucBerkeleyPos = new google.maps.LatLng(ucblat, ucblng);\n        let map = new google.maps.Map(document.getElementById(\"map\"), {\n            center: ucBerkeleyPos,\n            zoom: 14,\n            mapTypeId: \"roadmap\",\n            mapTypeControl: false,\n            fullscreenControl: false,\n            styles: stylers\n        });\n        // button for KDTree visualization\n        const visualizationButton = document.createElement(\"button\");\n        visualizationButton.setAttribute('id', \"visualization-button\");\n        if (!window.mapData.nearest_position) {\n            // start visualization button\n            visualizationButton.textContent = \"Visualize K-D Tree\";\n            visualizationButton.onclick = this.visualizeKDTree;\n        } else {\n            // restart button\n            visualizationButton.textContent = \"Restart\";\n            visualizationButton.onclick = () => { this.restartButtonClicked() };\n        }\n        map.controls[window.google.maps.ControlPosition.TOP_RIGHT].push(visualizationButton);\n        // add UC Berkeley on map\n        const ucb_icon = {\n            url: \"http://maps.google.com/mapfiles/ms/icons/blue-dot.png\",\n            size: new google.maps.Size(71, 71),\n            origin: new google.maps.Point(0, 0),\n            anchor: new google.maps.Point(17, 34),\n            scaledSize: new google.maps.Size(35, 35),\n        };\n        const ucb_marker = new google.maps.Marker({\n            map,\n            icon: ucb_icon,\n            title: 'UC Berkeley',\n            position: ucBerkeleyPos,\n        });\n        // Create the search box and link it to the UI element.\n        const input = document.getElementById(\"pac-input\");\n        let searchBox = new google.maps.places.SearchBox(input);\n        map.controls[google.maps.ControlPosition.TOP_LEFT].push(input);\n        // Bias the SearchBox results towards current map's viewport.\n        map.addListener(\"bounds_changed\", () => {\n            searchBox.setBounds(map.getBounds());\n        });\n        // handle markers\n        let curr_markers = window.mapData.markers;\n        let markers = [];\n        if (curr_markers.length != 0) {\n            // returned from KDTree visualizer\n            const bounds = new google.maps.LatLngBounds();\n            bounds.extend(ucb_marker.getPosition());\n            const bestIndex = this.findNearestMarker(curr_markers);\n            if (bestIndex || bestIndex === 0) { window.mapData.nearest_position.index = bestIndex }\n            for (let i = 0; i < curr_markers.length; i++) {\n                const marker = curr_markers[i];\n                let animation = null;\n                if (i == bestIndex) { animation = google.maps.Animation.BOUNCE }\n                marker.setMap(null);\n                const icon = {\n                    size: new google.maps.Size(71, 71),\n                    origin: new google.maps.Point(0, 0),\n                    anchor: new google.maps.Point(17, 34),\n                    scaledSize: new google.maps.Size(25, 25),\n                };\n                const position = {\n                    lat: marker.getPosition().lat(),\n                    lng: marker.getPosition().lng()\n                }\n                const title = marker.getTitle();\n                // Re-create a marker for each place.\n                markers.push(\n                    new google.maps.Marker({\n                        map,\n                        icon,\n                        title: title,\n                        position: position,\n                        animation: animation\n                    })\n                );\n                bounds.extend(position);\n            }\n            map.fitBounds(bounds);\n        }\n        window.mapData.markers = markers;\n        window.mapData.searchBox = searchBox;\n        window.mapData.ucb_marker = ucb_marker;\n        window.mapData.map = map;\n        // Listen for the event fired when the user selects a prediction and retrieve\n        // more details for that place.\n        searchBox.addListener(\"places_changed\", () => {\n            // first clearout previous visualization left overs\n            window.mapData.nearest_position = null;\n            window.mapData.nearestInfowindow = null;\n            const button = document.getElementById(\"visualization-button\");\n            button.textContent = \"Visualize K-D Tree\";\n            button.onclick = this.visualizeKDTree;\n            // handle search box\n            const places = searchBox.getPlaces();\n            if (places.length == 0) { return; }\n            // Clear out the old markers.\n            markers.forEach((marker) => {\n                marker.setMap(null);\n            });\n            markers = [];\n            // For each place, get the icon, name and location.\n            const bounds = new google.maps.LatLngBounds();\n            bounds.extend(ucBerkeleyPos);\n            places.forEach((place) => {\n                if (!place.geometry || !place.geometry.location) {\n                    console.log(\"Returned place contains no geometry\");\n                    return;\n                }\n                const icon = {\n                    size: new google.maps.Size(71, 71),\n                    origin: new google.maps.Point(0, 0),\n                    anchor: new google.maps.Point(17, 34),\n                    scaledSize: new google.maps.Size(25, 25),\n                };\n                // Create a marker for each place.\n                markers.push(\n                    new google.maps.Marker({\n                        map,\n                        icon,\n                        title: place.name,\n                        position: place.geometry.location,\n                    })\n                );\n                if (place.geometry.viewport) {\n                    // Only geocodes have viewport.\n                    bounds.union(place.geometry.viewport);\n                } else {\n                    bounds.extend(place.geometry.location);\n                }\n                // alert when there's only 1 result returned\n                if (places.length == 1) {\n                    alert('Only 1 place is found, which will display trivial visualization \\n \\n Try search general terms to display more places, e.g. Mcdonalds, Ramen')\n                }\n            });\n            console.log('reach here');\n            window.mapData.markers = markers;\n            map.fitBounds(bounds);\n        });\n\n        // reset the viewport if any marker goes out of viewport\n        const resetBound = () => {\n            // if nearest position is not null, searching is complete, simply return\n            if (window.mapData.nearest_position) { return }\n            const ucb_marker = window.mapData.ucb_marker;\n            let displayed_markers = window.mapData.markers.slice();\n            displayed_markers.push(ucb_marker);\n            let need_to_reset = false;\n            for (let i = 0; i < displayed_markers.length; i++) {\n                const m = displayed_markers[i];\n                const pixel_pos = getMarkerPixelCoordinate(m);\n                const x = pixel_pos.x;\n                const y = pixel_pos.y;\n                if (x <= 0 || y <= 0 || x >= window.innerWidth || y >= window.innerHeight) {\n                    need_to_reset = true;\n                    break;\n                }\n            }\n            if (need_to_reset) {\n                alert('You are about to drag or zoom some marker out of view port, which will affect neighbor searching visualization');\n                if (displayed_markers.length == 1) {\n                    // only UCB marker, reset the entire map\n                    map.setZoom(14);\n                    map.setCenter(ucBerkeleyPos);\n                } else {\n                    // query marker exist, fit bound   \n                    const bounds = new google.maps.LatLngBounds();\n                    displayed_markers.forEach((m) => {\n                        bounds.extend(m.getPosition());\n                    })\n                    map.fitBounds(bounds);\n                }\n            }\n        }\n        google.maps.event.addListener(map, 'bounds_changed', resetBound);\n    }\n\n    restartButtonClicked() {\n        window.mapData.nearest_position = null;\n        window.mapData.nearestInfowindow = null;\n        const button = document.getElementById(\"visualization-button\");\n        button.textContent = \"Start Visualization\";\n        button.onclick = this.visualizeKDTree;\n        // reset map\n        const google = window.google;\n        const map = window.mapData.map;\n        const markers = window.mapData.markers;\n        const ucBerkeleyPos = new google.maps.LatLng(ucblat, ucblng);\n        // clear all markers\n        console.log('marker is ', markers);\n        markers.forEach((marker) => {\n            marker.setMap(null);\n        })\n        window.mapData.markers = [];\n        // reset zoom and center\n        map.setZoom(14);\n        map.setCenter(ucBerkeleyPos);\n        document.getElementById('pac-input').style.display = 'inline-block';\n    }\n\n    findNearestMarker(markers) {\n        // return the index of markers that is closest to nearestPos\n        const nearestPos = window.mapData.nearest_position;\n        if (!nearestPos) { return }\n        let bestDist = Number.MAX_VALUE;\n        let bestIndex = null;\n        if (!markers || markers.length == 0) { return }\n        for (let i = 0; i < markers.length; i++) {\n            const marker = markers[i];\n            const markerPos = marker.getPosition();\n            const currDist = (markerPos.lat() - nearestPos.lat) ** 2 + (markerPos.lng() - nearestPos.lng) ** 2;\n            if (currDist <= bestDist) {\n                bestDist = currDist;\n                bestIndex = i;\n            }\n        }\n        return bestIndex;\n    }\n\n    render() {\n        return (\n            <div id='map-container'>\n                <div>\n                    <input\n                        id=\"pac-input\"\n                        class=\"controls\"\n                        type=\"text\"\n                        placeholder=\"Search Google Maps\"\n                    />\n                    <div id='map'></div>\n                </div>\n            </div>\n        )\n    }\n}\n\nexport class Marker {\n    constructor(position, title) {\n        this.position = position;\n        this.title = title;\n    }\n\n    getPosition() { return this.position }\n\n    getTitle() { return this.title }\n}","import { isValidElement } from 'react';\nimport { v4 as uuid } from 'uuid';\n\nfunction euclidean(dest_x, curr_x, dest_y, curr_y) {\n    return Math.sqrt((dest_x - curr_x) ** 2 + (dest_y - curr_y) ** 2);\n}\n\nexport class Dot {\n    constructor(position) {\n        this.position = position;\n    }\n\n    setIsVertical(isVertical) { this.isVertical = isVertical; }\n\n    getPosition() { return this.position; }\n\n    getIsVertical() {\n        if (this.isVertical) { return this.isVertical; }\n    }\n}\n\nexport class Line {\n    constructor(position, x_bound, y_bound, isVertical) {\n        this.position = position;\n        this.x_bound = x_bound;\n        this.y_bound = y_bound;\n        this.isVertical = isVertical;\n    }\n\n    getPosition() { return this.position; }\n\n    getIsVertical() { return this.isVertical }\n\n    getXBound() { return this.x_bound; }\n\n    getYBound() { return this.y_bound; }\n}\n\nexport default class KDTree {\n    constructor(dots, initial_x_bound, initial_y_bound) {\n        this.dots = dots;\n        this.root_dot = dots[Math.floor(dots.length / 2)];\n        this.root = new TreeNode(true, this.root_dot, initial_x_bound, initial_y_bound);\n        this.root.sortCoordinates(dots, true);\n        this.root.constructTree(dots);\n    }\n\n    getRoot() { return this.root; }\n\n    iterateTree() {\n        /** return the tree iteration with BFS order */\n        const root = this.getRoot();\n        var result = [];\n        if (root) { root.iterate(result); }\n        return result;\n    }\n\n    getNodeTraversedAfterInsertion(position) {\n        /** The dot at 'position' is also included in the result, as a fake new dot */\n        const root = this.getRoot();\n        var result = [];\n        if (root) { root.getNodeTraversedAfterInsertion(result, position); }\n        return result;\n    }\n\n    performNearestSearching(position) {\n        /** \n         * This function searches the nearest tree node around 'position', \n         * and returns:\n         *      1. the nearest neighbor\n         *      2. all nodes that are traversed during searching for animation purpose, excluding those traversed during insertion\n         * */\n        const dest_x = position.x;\n        const dest_y = position.y;\n        var stack = this.getNodeTraversedAfterInsertion(position);\n        stack.pop(); // pop the fake dot that is not part of the actual tree\n        var curr_node = stack[stack.length - 1];\n        var curr_x = curr_node.getPosition().x;\n        var curr_y = curr_node.getPosition().y;\n        var best_distance = euclidean(dest_x, curr_x, dest_y, curr_y);\n        var nearest_neighbor = curr_node;\n        var visited = new Set();\n\n        var bound_animation = []; // for displaying bound change\n        var crossing_animation = []; // for displaying circle drawing\n        while(stack.length != 0) {\n            curr_node = stack.pop();\n            visited.add(curr_node.getID());\n            // console.log(curr_node, visited);\n            curr_x = curr_node.getPosition().x;\n            curr_y = curr_node.getPosition().y;\n            if (euclidean(dest_x, curr_x, dest_y, curr_y) <= best_distance) {\n                best_distance = euclidean(dest_x, curr_x, dest_y, curr_y);\n                nearest_neighbor = curr_node;\n            }\n            if (curr_node.right && !visited.has(curr_node.right.getID())) {\n                if (curr_node.intersectDownOrRight(dest_x, dest_y, best_distance)) {\n                    stack.push(curr_node.right);\n                    bound_animation.push(curr_node);\n                } else {\n                    bound_animation.push(null);\n                }\n                var direction = curr_node.isVertical ? 'right' : 'down';\n                crossing_animation.push({\n                    length: best_distance,\n                    direction: direction\n                });\n            }\n            if (curr_node.left && !visited.has(curr_node.left.getID())) {\n                if (curr_node.intersectUpOrLeft(dest_x, dest_y, best_distance)) {\n                    stack.push(curr_node.left);\n                    bound_animation.push(curr_node);\n                } else {\n                    bound_animation.push(null);\n                }\n                var direction = curr_node.isVertical ? 'left' : 'up';\n                crossing_animation.push({\n                    length: best_distance,\n                    direction: direction\n                });\n            }\n\n        }\n        return {\n            nearest: nearest_neighbor,\n            bound_animation: bound_animation,\n            crossing_animation: crossing_animation\n        }\n    }\n}\n\nexport class TreeNode {\n    constructor(isVertical, dot, x_bound, y_bound) {\n        /**\n         * dots: array, a list of dot of all points (markers) on the screen\n         * isVertical: boolean, whether or not current node is vertically cutting the hyperplane => sorted by x: true; sorted by y: false\n         * Dot: instance of the dot, position on the screen that the node correspond to\n         * bound: {min, max}, line drawing purposes\n         */\n        this.isVertical = isVertical;\n        this.dot = dot;\n        this.dot.setIsVertical(isVertical);\n        this.x_bound = x_bound;\n        this.y_bound = y_bound;\n        this.line = new Line(dot.getPosition(), x_bound, y_bound, isVertical);\n        this.id = uuid();\n    }\n\n    getID() { return this.id; }\n\n    getLine() { return this.line; }\n\n    getPosition() { return this.getDot().getPosition(); }\n\n    getDot() { return this.dot; }\n\n    getIsVertical() { return this.isVertical }\n\n    getXBound() { return this.x_bound; }\n\n    getYBound() { return this.y_bound; }\n\n    sortCoordinates(dots, isSortingByX) {\n        /* isSortingByX: boolean */\n        if (isSortingByX) {\n            dots.sort((dot1, dot2) => {\n                const x1 = dot1.getPosition().x;\n                const x2 = dot2.getPosition().x;\n                if (x1 < x2) { return -1; }\n                if (x1 > x2) { return 1; }\n                return 0;\n            })\n        } else {\n            dots.sort((dot1, dot2) => {\n                const y1 = dot1.getPosition().y;\n                const y2 = dot2.getPosition().y;\n                if (y1 < y2) { return -1; }\n                if (y1 > y2) { return 1; }\n                return 0;\n            })\n        }\n    }\n\n    constructTree(dots) {\n        /** dots are sorted according to this.isVertical */\n        if (dots.length <= 1) { return; }\n        var leftHalf = dots.slice(0, Math.floor(dots.length / 2));\n        var rightHalf = dots.slice(Math.floor(dots.length / 2) + 1, dots.length);\n        this.sortCoordinates(leftHalf, !this.isVertical);\n        this.sortCoordinates(rightHalf, !this.isVertical);\n        if (leftHalf.length != 0) {\n            const left_dot = leftHalf[Math.floor(leftHalf.length / 2)];\n            var left_x_bound, left_y_bound;\n            if (this.isVertical) {\n                left_x_bound = { min: this.x_bound.min, max: this.dot.position.x };\n                left_y_bound = this.y_bound;\n            } else {\n                left_x_bound = this.x_bound;\n                left_y_bound = { min: this.y_bound.min, max: this.dot.position.y };\n            }\n            this.left = new TreeNode(!this.isVertical, left_dot, left_x_bound, left_y_bound);\n            this.left.constructTree(leftHalf);\n        }\n        if (rightHalf.length != 0) {\n            const right_dot = rightHalf[Math.floor(rightHalf.length / 2)];\n            var right_x_bound, right_y_bound;\n            if (this.isVertical) {\n                right_x_bound = { min: this.dot.position.x, max: this.x_bound.max };\n                right_y_bound = this.y_bound;\n            } else {\n                right_x_bound = this.x_bound;\n                right_y_bound = { min: this.dot.position.y, max: this.y_bound.max };\n            }\n            this.right = new TreeNode(!this.isVertical, right_dot, right_x_bound, right_y_bound);\n            this.right.constructTree(rightHalf);\n        }\n    }\n\n    iterate(lst) {\n        /** add all tree node element to the list in BFS order*/\n        lst.push(this);\n        if (this.left) { this.left.iterate(lst); }\n        if (this.right) { this.right.iterate(lst); }\n    }\n\n    getNodeTraversedAfterInsertion(stack, position) {\n        const dest_x = position.x;\n        const dest_y = position.y;\n        const curr_x = this.getDot().getPosition().x;\n        const curr_y = this.getDot().getPosition().y;\n        stack.push(this);\n        if (this.isVertical) { // comparing x\n            if (dest_x < curr_x) {\n                if (!this.left) {\n                    stack.push(this.getInsertedDestinationNode(position, curr_x, curr_y));\n                    return stack;\n                }\n                return this.left.getNodeTraversedAfterInsertion(stack, position);\n            }\n            else {\n                if (!this.right) {\n                    stack.push(this.getInsertedDestinationNode(position, curr_x, curr_y));\n                    return stack;\n                }\n                return this.right.getNodeTraversedAfterInsertion(stack, position);\n            }\n        } else { // comparing y\n            if (dest_y < curr_y) {\n                if (!this.left) {\n                    stack.push(this.getInsertedDestinationNode(position, curr_x, curr_y));\n                    return stack;\n                }\n                return this.left.getNodeTraversedAfterInsertion(stack, position);\n            }\n            else {\n                if (!this.right) {\n                    stack.push(this.getInsertedDestinationNode(position, curr_x, curr_y));\n                    return stack;\n                }\n                return this.right.getNodeTraversedAfterInsertion(stack, position);\n            }\n        }\n    }\n\n    getInsertedDestinationNode(position, curr_x, curr_y) {\n        /** In order to get the correct bound display, the dot at 'position' need to be added as a fake dot */\n        const dest_x = position.x;\n        const dest_y = position.y;\n        var inserted_x_bound;\n        var inserted_y_bound;\n        if (this.isVertical) { // comparing x\n            inserted_y_bound = this.y_bound;\n            if (dest_x < curr_x) {\n                inserted_x_bound = { min: this.x_bound.min, max: this.dot.position.x };\n            }\n            else {\n                inserted_x_bound = { min: this.dot.position.x, max: this.x_bound.max };\n            }\n        } else { // comparing y\n            inserted_x_bound = this.x_bound;\n            if (dest_y < curr_y) {\n                inserted_y_bound = { min: this.y_bound.min, max: this.dot.position.y };\n            }\n            else {\n                inserted_y_bound = { min: this.dot.position.y, max: this.y_bound.max };\n            }\n        }\n        const inserted_dot = new Dot(position);\n        return new TreeNode(!this.isVertical, inserted_dot, inserted_x_bound, inserted_y_bound);\n    }\n\n    getNodesTraversedAfterClosestSearching(stack, position) {\n        /** \n         * stack: array of TreeNodes \n         * */\n        const dest_x = position.x;\n        const dest_y = position.y;\n        const curr_x = stack[stack.length - 1].getPosition().x;\n        const curr_y = stack[stack.length - 1].getPosition().y;\n        var best_distance = euclidean(dest_x, curr_x, dest_y, curr_y);\n    }\n\n    intersectUpOrLeft(dest_x, dest_y, best_distance) {\n        /** return true if any up or left hyperplane is intersected */\n        // left\n        if (this.isVertical) { return dest_x - best_distance <= this.getPosition().x; }\n        // up\n        else { return dest_y - best_distance <= this.getPosition().y } \n    }\n\n    intersectDownOrRight(dest_x, dest_y, best_distance) {\n        /** return true if any down or right hyperplane is intersected */\n        // right\n        if (this.isVertical) { return dest_x + best_distance >= this.getPosition().x; }\n        // down\n        else { return dest_y + best_distance >= this.getPosition().y } \n    }\n}","import React, { Component } from 'react';\nimport '../View/NeighborFindingVisualizer.css';\nimport KDTree, { Dot, Line, TreeNode } from '../Model/KDTree.js';\nimport Popup from 'reactjs-popup';\n\nconst ANIMATION_LAG = 1500;\nconst LINE_DISPLAY_LAG = 200;\nconst ucblat = 37.871416963460454;\nconst ucblng = -122.26007750513202;\n\nfunction randomIntFromInterval(min, max) {\n    // min and max included\n    return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\nexport default class NeighborFindingVisualizer extends Component {\n\n    constructor(props) {\n        super(props);\n        this.state = {\n            tree_nodes: [], // {node, is_dot_displayed, is_line_displayed}\n            searching_bound: { x_bound: { min: 0, max: window.innerWidth }, y_bound: { min: 0, max: window.innerHeight } },\n            animation_speed: 2,\n            radar_radius: 20,\n            radar_direction: 'up',\n            running_status: 'constructing' // allowed status: constructing, searching, none\n        }\n    }\n\n    componentDidMount() {\n        const markers = window.mapData.markers;\n        const dots = this.markerToPixelDots(markers);\n        const kdtree = this.getKDTree(dots);\n        this.KDTree = kdtree;\n        const nodes = kdtree.iterateTree();\n        const tree_nodes = [];\n        nodes.forEach((node) => {\n            tree_nodes.push({\n                node: node,\n                is_dot_displayed: false,\n                is_line_displayed: false,\n                drawing_line_length: 0\n            })\n        });\n        this.setState({ tree_nodes: tree_nodes });\n        setTimeout(() => {\n            this.displaySearchingAnimation();\n        }, 1000);\n    }\n\n    markerToPixelDots(markers) {\n        /* \n        This function get pixel coordinate of markers on screen, \n        so DOM elements can be drawn on the position of markers without google map instance available \n        # Parameter markers: array of google.Maps.markers\n        # Return: array of pixel coordinate {x, y} (AKA {left, top})\n        */\n        const map = window.mapData.map;\n        if (!map) { return; }\n        var scale = Math.pow(2, map.getZoom());\n        var nw = new window.google.maps.LatLng(\n            map.getBounds().getNorthEast().lat(),\n            map.getBounds().getSouthWest().lng()\n        );\n        var worldCoordinateNW = map.getProjection().fromLatLngToPoint(nw);\n        var result = [];\n        markers.forEach((marker) => {\n            if (marker) {\n                var worldCoordinate = map.getProjection().fromLatLngToPoint(marker.getPosition());\n                var pixelOffset = {\n                    x: Math.floor((worldCoordinate.x - worldCoordinateNW.x) * scale),\n                    y: Math.floor((worldCoordinate.y - worldCoordinateNW.y) * scale)\n                }\n                result.push(new Dot(pixelOffset));\n            }\n        })\n        return result;\n\n        /**\n         * For testing purpose, get 20 random dots on the screen\n         */\n        // var result = [];\n        // for (let i = 0; i < 20; i++) {\n        //     var position = {\n        //         x: Math.floor(randomIntFromInterval(150, window.screen.width - 150)),\n        //         y: Math.floor(randomIntFromInterval(150, window.innerHeight - 150))\n        //     }\n        //     result.push(new Dot(position));\n        // }\n        // return result\n    }\n\n    getLatLngFromPixelOffset(position) {\n        const map = window.mapData.map;\n        if (!map) { return; }\n        var scale = Math.pow(2, map.getZoom());\n        var nw = new window.google.maps.LatLng(\n            map.getBounds().getNorthEast().lat(),\n            map.getBounds().getSouthWest().lng()\n        );\n        var worldCoordinateNW = map.getProjection().fromLatLngToPoint(nw); // in pixel\n        const x = position.x / scale;\n        const y = position.y / scale;\n        const point = new window.google.maps.Point(x + worldCoordinateNW.x, y + worldCoordinateNW.y);\n        const result = map.getProjection().fromPointToLatLng(point);\n        return {\n            lat: result.lat(),\n            lng: result.lng()\n        }\n    }\n\n    getUCBDot() {\n        const ucb_marker = [window.mapData.ucb_marker];\n        const ucb_dot = this.markerToPixelDots(ucb_marker)[0];\n        var position = ucb_dot.getPosition();\n        return new Dot(position);\n\n        // var testPosition = { x: 700, y: 400 }\n        // return new Dot(testPosition);\n    }\n\n    getKDTree(dots) {\n        // The root coordinate is sorted by x value and cut the hyperplane vertically\n        dots.sort((dot1, dot2) => {\n            const x1 = dot1.getPosition().x;\n            const x2 = dot2.getPosition().x;\n            if (x1 < x2) { return -1; }\n            if (x1 > x2) { return 1; }\n            return 0;\n        });\n        const x_bound = { min: 0, max: window.innerWidth };\n        const y_bound = { min: 0, max: window.innerHeight };\n        const kdtree = new KDTree(dots, x_bound, y_bound);\n        return kdtree;\n    }\n\n    drawBoundAnimatedly(animation_begin_time, time_interval, from_bound, to_bound) {\n        /** \n         * Redraw the bound animatedly\n         * Return: time elasped from the animation\n         */\n        const num_intervals = 25;\n        const searching_bound = from_bound;\n        var x_bound_min = from_bound.x_bound.min;\n        var x_bound_max = from_bound.x_bound.max;\n        var y_bound_min = from_bound.y_bound.min;\n        var y_bound_max = from_bound.y_bound.max;\n\n        const to_x_bound = to_bound.x_bound;\n        const to_y_bound = to_bound.y_bound;\n        // calculate difference\n        const x_bound_min_diff = to_x_bound.min - x_bound_min;\n        const x_bound_max_diff = to_x_bound.max - x_bound_max;\n        const y_bound_min_diff = to_y_bound.min - y_bound_min;\n        const y_bound_max_diff = to_y_bound.max - y_bound_max;\n        // inner loop to make the bound drawing process animated\n        for (let j = 0; j < num_intervals; j++) {\n            const local_xmin = x_bound_min + x_bound_min_diff * ((j + 1) / num_intervals);\n            const local_xmax = x_bound_max + x_bound_max_diff * ((j + 1) / num_intervals);\n            const local_ymin = y_bound_min + y_bound_min_diff * ((j + 1) / num_intervals);\n            const local_ymax = y_bound_max + y_bound_max_diff * ((j + 1) / num_intervals);\n            setTimeout(() => {\n                searching_bound.x_bound = {\n                    min: local_xmin,\n                    max: local_xmax\n                }\n                searching_bound.y_bound = {\n                    min: local_ymin,\n                    max: local_ymax\n                }\n                this.setState({ searching_bound: searching_bound });\n            }, animation_begin_time + time_interval * (j / num_intervals));\n        }\n    }\n\n    drawLineAnimatedly(animation_begin_time, time_interval, length, direction) {\n        const num_intervals = 20;\n        for (let j = 0; j < num_intervals; j++) {\n            setTimeout(() => {\n                var displayed_length = 0;\n                displayed_length += length * ((j + 1) / num_intervals);\n                this.setState({ radar_radius: displayed_length, radar_direction: direction, running_status: 'searching' });\n            }, animation_begin_time + time_interval * (j / num_intervals));\n        }\n    }\n\n    drawColoredDotAtTime(animation_begin_time, dotID, prevDotID, prevDotColor) {\n        setTimeout(() => {\n            document.getElementById(dotID).style.backgroundColor = 'crimson';\n            if (prevDotID) {\n                document.getElementById(prevDotID).style.backgroundColor = prevDotColor\n            }\n        }, animation_begin_time);\n    }\n\n    drawLine(start_x, start_y, length, thickness, color, direction, display, border_radius) {\n        const isVertical = (direction == 'up' || direction == 'down') ? true : false;\n        if (direction === 'right' || direction == 'down') {\n            // drawing from left to right or top to bottom => specify left and top\n            return (\n                <div\n                    className='line'\n                    style={isVertical ?\n                        {\n                            left: `${start_x}px`, top: `${start_y}px`, backgroundColor: color, borderRadius: `${border_radius}px`,\n                            height: `${length}px`, display: display, width: `${thickness}px`\n                        } :\n                        {\n                            left: `${start_x}px`, top: `${start_y}px`, backgroundColor: color, borderRadius: `${border_radius}px`,\n                            width: `${length}px`, display: display, height: `${thickness}px`\n                        }}>\n                </div>\n            )\n        } else {\n            // drawing from right to left or bottom to top => specify right and bottom\n            return (\n                <div\n                    className='line'\n                    style={isVertical ?\n                        {\n                            right: `${window.innerWidth - start_x - thickness + 1}px`, bottom: `${window.innerHeight - start_y}px`,\n                            height: `${length}px`, display: display, width: `${thickness}px`,\n                            backgroundColor: color, borderRadius: `${border_radius}px`,\n                        } :\n                        {\n                            right: `${window.innerWidth - start_x}px`, bottom: `${window.innerHeight - start_y - thickness + 1}px`,\n                            width: `${length}px`, display: display, height: `${thickness}px`,\n                            backgroundColor: color, borderRadius: `${border_radius}px`,\n                        }}>\n                </div>\n            )\n        }\n    }\n\n    displaySearchingAnimation() {\n        /** \n         * Get UCB dot position, perform insertion\n         */\n        const animation_speed = 1 / (2 ** (this.state.animation_speed));\n        var tree_nodes = this.state.tree_nodes;\n        tree_nodes.forEach((tree_node) => {\n            tree_node.is_dot_displayed = false;\n            tree_node.is_line_displayed = false;\n        })\n        this.setState({\n            tree_nodes: tree_nodes,\n            running_status: 'constructing'\n        })\n        // animate KDTree construction\n        for (let i = 0; i < tree_nodes.length; i++) {\n            const tree_node = tree_nodes[i];\n            setTimeout(() => {\n                tree_node.is_dot_displayed = true;\n                this.setState({ tree_nodes: tree_nodes })\n            }, ANIMATION_LAG * animation_speed * i);\n            setTimeout(() => {\n                tree_node.is_line_displayed = true;\n                this.setState({ tree_nodes: tree_nodes })\n            }, ANIMATION_LAG * animation_speed * i + LINE_DISPLAY_LAG);\n        }\n        var time_elapsed = ANIMATION_LAG * animation_speed * tree_nodes.length + LINE_DISPLAY_LAG;\n        // prepare for insertion animatoin\n        const ucb_dot = this.getUCBDot();\n        const ucb_pos = { x: ucb_dot.getPosition().x, y: ucb_dot.getPosition().y }\n\n        const insertion_animation = this.KDTree.getNodeTraversedAfterInsertion(ucb_pos);\n        const obj = this.KDTree.performNearestSearching(ucb_pos);\n        const nearest = obj.nearest; // class TreeNode\n        const bound_animation = obj.bound_animation;\n        const crossing_animation = obj.crossing_animation;\n        const nearest_id = nearest.getID();\n        // animate insertion process\n        var bound = this.state.searching_bound;\n        for (let i = 0; i < insertion_animation.length; i++) {\n            const node = insertion_animation[i];\n            const to_bound = {\n                x_bound: node.getXBound(),\n                y_bound: node.getYBound()\n            }\n            const animation_begin_time = time_elapsed + ANIMATION_LAG * animation_speed * i;\n            const time_interval = ANIMATION_LAG * animation_speed;\n            this.drawBoundAnimatedly(animation_begin_time, time_interval, bound, to_bound);\n            bound = to_bound;\n        }\n        var time_elapsed = time_elapsed + ANIMATION_LAG * animation_speed * (insertion_animation.length + 1);\n        // animate searching process\n        setTimeout(() => {\n            this.setState({ running_status: 'searching' })\n        }, time_elapsed);\n        let prevBestNodeID; let prevBestNodeColor; // animation purpose\n        for (let i = 0; i < bound_animation.length; i++) {\n            const node = bound_animation[i];\n            const line_info = crossing_animation[i];\n            const line_length = line_info.length;\n            const line_direction = line_info.direction;\n            // draw the animated line\n            const line_animation_begin_time = time_elapsed + ANIMATION_LAG * animation_speed * 2 * i;\n            const time_interval = ANIMATION_LAG * animation_speed;\n            this.drawLineAnimatedly(line_animation_begin_time, time_interval, line_length, line_direction);\n            if (node) {\n                // redraw the bound\n                const bound_animation_begin_time = time_elapsed + ANIMATION_LAG * animation_speed * (2 * i + 1);\n                const to_x_bound = {\n                    min: Math.min(bound.x_bound.min, node.getXBound().min),\n                    max: Math.max(bound.x_bound.max, node.getXBound().max)\n                }\n                const to_y_bound = {\n                    min: Math.min(bound.y_bound.min, node.getYBound().min),\n                    max: Math.max(bound.y_bound.max, node.getYBound().max)\n                }\n                const to_bound = {\n                    x_bound: to_x_bound,\n                    y_bound: to_y_bound\n                }\n                this.drawBoundAnimatedly(bound_animation_begin_time, time_interval, bound, to_bound);\n                bound = to_bound;\n            }\n        }\n        time_elapsed += ANIMATION_LAG * animation_speed * bound_animation.length * 2;\n        setTimeout(() => {\n            if (prevBestNodeID) {\n                document.getElementById(prevBestNodeID).style.backgroundColor = prevBestNodeColor;\n            }\n            this.setState({ running_status: 'none' })\n            const nearest_dot = document.getElementById(nearest_id);\n            nearest_dot.style.backgroundColor = 'crimson';\n            nearest_dot.style.opacity = 1;\n            const lines = document.getElementsByClassName('line');\n            for (let k = 0; k < lines.length; k++) { lines[k].style.opacity = 0.3 }\n        }, time_elapsed + LINE_DISPLAY_LAG);\n        setTimeout(() => {\n            const nearest_position = nearest.getPosition();\n            const nearest_latlng = this.getLatLngFromPixelOffset(nearest_position);\n            window.mapData.nearest_position = nearest_latlng;\n            this.props.KDTreeToMap();\n        }, time_elapsed + LINE_DISPLAY_LAG + 1500);\n    }\n\n    render() {\n        const ucb_dot = this.getUCBDot();\n        const tree_nodes = this.state.tree_nodes;\n        const searching_x_min = this.state.searching_bound.x_bound.min;\n        const searching_x_max = this.state.searching_bound.x_bound.max;\n        const searching_y_min = this.state.searching_bound.y_bound.min;\n        const searching_y_max = this.state.searching_bound.y_bound.max;\n        const bound_thickness = 5;\n        const radar_radius = this.state.radar_radius;\n        const radar_direction = this.state.radar_direction;\n        const running_status = this.state.running_status;\n        const is_radar_displayed = running_status == 'searching' ? 'inline-block' : 'none';\n        const popUpContent = () => {\n            if (running_status === 'constructing') {\n                return <div className='popup-container'> Constructing K-D Tree </div>\n            }\n            else if (running_status === 'searching') {\n                return (\n                    <div className='popup-container' style={{ textAlign: 'left' }}>\n                        <div> Searching... </div>\n                        <div style={{ marginTop: '5px', marginBottom: '10px' }}> * Yellow bar: best distance found so far </div>\n                        <div\n                            style={{\n                                backgroundColor: 'gold', borderRadius: `${2}px`,\n                                width: `${100}px`, height: `${5}px`\n                            }}>\n                        </div>\n                        <div style={{ height: '10px' }}></div>\n                    </div>\n                )\n            }\n            else {\n                return <div className='popup-container'> Nearest neighbor found </div>\n            }\n        }\n        const infoPopUp = () => (\n            <Popup\n                trigger={\n                    <button style={{\n                        right: '4px', bottom: '4px', width: '35px', height: '35px', position: 'absolute', borderRadius: '5px',\n                        backgroundImage: `url(${'../question-mark.png'})`, opacity: 0.5,\n                        backgroundSize: 'cover', backgroundPosition: 'center'\n                    }}>\n                    </button>\n                }\n                position={'top right'}\n                on={['hover', 'focus']}\n                arrow={true}\n            >\n                {popUpContent()}\n            </Popup>\n        );\n        return (\n            <div className='visualizer-container'>\n                {infoPopUp()}\n                <div\n                    className='bound'\n                    id='bound-top'\n                    style={{ height: `${bound_thickness}px`, left: searching_x_min, top: searching_y_min, width: searching_x_max - searching_x_min, marginTop: `${-bound_thickness / 2}px` }} />\n                <div\n                    className='bound'\n                    id='bound-bottom'\n                    style={{ height: `${bound_thickness}px`, left: searching_x_min, top: searching_y_max, width: searching_x_max - searching_x_min, marginTop: `${-bound_thickness / 2}px` }} />\n                <div\n                    className='bound'\n                    id='bound-left'\n                    style={{ width: `${bound_thickness}px`, left: searching_x_min, top: searching_y_min, height: searching_y_max - searching_y_min, marginLeft: `${-bound_thickness / 2}px` }} />\n                <div\n                    className='bound'\n                    id='bound-right'\n                    style={{ width: `${bound_thickness}px`, left: searching_x_max, top: searching_y_min, height: searching_y_max - searching_y_min, marginLeft: `${-bound_thickness / 2}px` }} />\n                <div className='dot' style={{ left: `${ucb_dot.getPosition().x}px`, top: `${ucb_dot.getPosition().y}px`, backgroundColor: 'blue' }} />\n                {this.drawLine(\n                    ucb_dot.getPosition().x - bound_thickness / 2, ucb_dot.getPosition().y - bound_thickness / 2,\n                    radar_radius, bound_thickness, 'gold', radar_direction, is_radar_displayed, 4)}\n                {tree_nodes.map((obj, idx) => {\n                    const node = obj.node;\n                    const dot = node.getDot();\n                    const line = node.getLine();\n                    let is_dot_displayed = obj.is_dot_displayed;\n                    let is_line_displayed = obj.is_line_displayed;\n                    const node_id = node.getID();\n                    if (running_status == 'none') { is_dot_displayed = false }\n                    // display info\n                    const isVertical = line.getIsVertical();\n                    const x = line.getPosition().x;\n                    const y = line.getPosition().y;\n                    const x_bound = line.getXBound();\n                    const y_bound = line.getYBound();\n                    const dot_opacity = is_dot_displayed ? 1 : 0.3;\n                    const line_display = is_line_displayed ? 'inline-block' : 'none';\n                    const line_color = isVertical ? 'rgb(187, 145, 248)' : 'mediumaquamarine';\n                    const dot_color = is_dot_displayed ? line_color : 'crimson';\n                    const start_x = isVertical ? x - 1 : x_bound.min;\n                    const start_y = isVertical ? y_bound.min : y - 1;\n                    const length = isVertical ? y_bound.max - y_bound.min : x_bound.max - x_bound.min;\n                    const direction = isVertical ? 'down' : 'right';\n                    return (\n                        <div>\n                            {/* draw dot */}\n                            <div\n                                className='dot'\n                                id={node_id}\n                                style={{ left: x, top: y, opacity: dot_opacity, backgroundColor: dot_color }}>\n                            </div>\n                            {/* draw line */}\n                            {this.drawLine(start_x, start_y, length, 2, line_color, direction, line_display, 1)}\n                        </div>\n                    )\n                })}\n            </div>\n        )\n    }\n}\n","import React, { Component, version } from 'react';\nimport Map from './Map.jsx';\nimport NeighborFindingVisualizer from './NeighborFindingVisualizer.jsx';\nimport '../View/Display.css';\nimport Popup from 'reactjs-popup';\n\n/* This class is implemented for switching between Map display and Visualizer display */\nexport default class Display extends Component {\n\n    constructor(props) {\n        super(props);\n        this.state = {\n            viewToDisplay: Map,\n        }\n        this.visualizeKDTree = this.visualizeKDTree.bind(this);\n        this.KDTreeToMap = this.KDTreeToMap.bind(this);\n    }\n\n    visualizeKDTree() {\n        let markers = window.mapData.markers;\n        if (!markers || markers.length == 0) {\n            alert('Please search some locations before visualization \\n \\n e.g. McDonalds, Ramen');\n            return;\n        }\n        const map = window.mapData.map;\n        for (let i = 0; i < 3; i++) {\n            setTimeout(() => {\n                var stylers = [{\n                    \"stylers\": [{\n                        \"lightness\": -50 - (i * 20)\n                    }]\n                }];\n                map.setOptions({\n                    styles: stylers\n                })\n            }, i * 400);\n        }\n        setTimeout(() => {\n            this.setState({ viewToDisplay: NeighborFindingVisualizer });\n        }, 3 * 400);\n    }\n\n    KDTreeToMap() {\n        this.setState({ viewToDisplay: Map });\n        document.getElementById('pac-input').style.display = 'none';\n        setTimeout(() => {\n            if (window.mapData.nearest_position) {\n                const google = window.google;\n                const markers = window.mapData.markers;\n                const ucb_marker = window.mapData.ucb_marker;\n                const map = window.mapData.map;\n                const nearest_index = window.mapData.nearest_position.index;\n                markers.forEach((marker) => {\n                    marker.setMap(null);\n                })\n                // get nearest marker\n                const nearest_marker = window.mapData.markers[nearest_index];\n                const bounds = new google.maps.LatLngBounds();\n                bounds.extend(ucb_marker.getPosition());\n                bounds.extend(nearest_marker.getPosition());\n                nearest_marker.setAnimation(null);\n                nearest_marker.setMap(map);\n                map.fitBounds(bounds);\n                // info window\n                const infowindow = window.mapData.nearestInfowindow;\n                infowindow.open({\n                    anchor: nearest_marker,\n                    map,\n                    shouldFocus: false,\n                });\n            }\n        }, 3000);\n    }\n\n    render() {\n        const ViewToDisplay = this.state.viewToDisplay;\n        const popUpDisplay = window.mapData.shouldPopUpDisplay ? 'inline-block' : 'none';\n        window.mapData.shouldPopUpDisplay = false;\n        return (\n            <div>\n                {/* <NeighborFindingVisualizer></NeighborFindingVisualizer> */}\n\n                <Popup position=\"right center\" defaultOpen={true}>\n                    <div id='popup-container' style={{display: popUpDisplay}}>\n                        <h3 className='popup-h3-text'>Welcome to K-D Tree Visualizer!</h3>\n                        <h6 className='popup-h6-text'>K-D Tree is a powerful space-partitioning data structure that is widely used for nearest neighbor searching in map applications.</h6>\n                        <h6 className='popup-h6-text'>So, what would it looks like behind the scene if Google Maps uses K-D tree for nearest neighbor searching? This visualizer present you the searching process near UC Berkeley among locations of your choice.</h6>\n                        {/* <img width='300px' height='300px' src={process.env.PUBLIC_URL + 'googlemaps.jpeg'}></img> */}\n                        <img width='300px' height='300px' src={require('../googlemaps.jpeg')}></img>\n                        <p>Click the map to start</p>\n                    </div>\n                </Popup>\n                    <ViewToDisplay\n                        visualizeKDTree={this.visualizeKDTree}\n                        KDTreeToMap={this.KDTreeToMap} ></ViewToDisplay>\n            </div>\n                )\n    }\n}","import logo from './logo.svg';\nimport './App.css';\nimport Display from './Controller/Display.jsx';\n\nfunction App() {\n    window.mapData = {\n        map: null,\n        searchBox: null,\n        ucb_marker: null,\n        markers: [],\n        nearest_position: null,\n        nearestInfowindow: null,\n        shouldPopUpDisplay: true\n    }\n    return (\n        <Display></Display>\n    );\n}\n\nexport default App;","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}